![image](https://github.com/Mingadinga/2023_Study_CS/assets/53958188/68d8e9b5-e020-468f-86b5-9ccf5d52b1bf)

- 클라이언트 PC가 인터넷을 통해 서버에서 파일을 가져오는 상황
- TCP/IP 연결을 한 경우, 수신 측과 송신 측에 발생하는 일을 알아보자.
- 요약하자면 네트워크 속도가 느린 이유가 송신하는 쪽이 느린 것일 수도 있지만, ACK가 도착하지 않아 서버가 기다리는 상황이거나 수신하는 쪽의 TCP 버퍼가 빨리 안 비워져서 그런 것일 수도 있음!
- 수신 측 소켓의 receive 속도가 네트워크 수신 속도보다 빨라야 한다.

# 서버 컴퓨터에서 일어나는 일

- 소켓 연산 용어 정리 : Receive(Read), Send(Write)
- 디스크 → 프로세스 : 파일을 디스크에서 읽어 `프로세스의 메모리`(버퍼)로 가져온다. 전체 파일을 가져오는 것이 아니라, 프로세스에 할당되는 메모리만큼 잘라서 가져온다.
- 프로세스 → TCP : 프로세스의 버퍼에 쌓인 메모리를 `TCP 버퍼`로 복사해옴.
- TCP → IP : TCP 버퍼를 Segment로 쪼개고, IP 패킷으로 캡슐화함.
- IP → NI : IP 패킷을 Frame으로 캡슐화해서 전송한다. 패킷이 택배 상자라면, Frame은 택배를 운반하는 트럭이다. 패킷은 엔드포인트 관계에서 존재하지만, 프레임은 중간에 만들어졌다 사라지기를 반복한다. 트럭의 목적지는 중간 허브라고 생각하면 됨.

# 클라이언트 컴퓨터에서 일어나는 일

- NI → IP : 클라이언트 NI으로 Frame 도착하면 IP 계층에 올려서 패킷을 꺼냄.
- IP → TCP : 패킷 캡슐해제해서 Segment 꺼냄. TCP 버퍼에 적재.

## ACK

- 서버가 위 과정을 반복해서 패킷 두개 받아 TCP 버퍼에 적재한 후, 세번째꺼 보내라는 의미로 서버에 `ACK#3` 날림.
- 서버는 패킷 두개 보내놓고 ACK#3 기다리는데, 이 기다리는 부분에서 `속도 지연` 발생. (TCP가 UDP보다 느린 이유)

## 윈도우 사이즈

- 수신 측의 TCP 버퍼 사이즈. ACK 보낼 때 이 정보를 같이 보냄.
- 서버는 ACK가 오고 나면 전송할지 말지 결정한다. 이때 Window Size > MSS, 즉 여유 있으면 패킷을 보내지만, 그렇지 않으면 안 보내서 wait 걸림. 진짜 중요
- 느린 이유가 서버가 느려서가 아니라 클라가 TCP 버퍼를 빨리 안 비워서일 수도 있음! File IO 버퍼로 빨리 퍼 올려야한다. 즉 `소켓의 receive 속도가 네트워크 수신 속도보다 빨라야 한다`. 네트워크의 문제가 아니라 소켓 프로그램의 문제일 수 있음!